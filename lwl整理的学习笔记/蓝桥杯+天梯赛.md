# 第十五届省赛C/C++ 大学 B 组

##### [R 格式 - 蓝桥云课](https://www.lanqiao.cn/problems/19710/learning/)

问题：小数乘2的n次方，四舍五入变整数

思路：小数长度过大，用字符串。模拟高精度乘法，carry代表进位。

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
void solve()
{
    int n;
    cin>>n;
    string s;
    cin>>s;
    int k;
    vector<int> p;
    for(int i=s.size()-1;i>=0;i--)
    {
      if(s[i]!='.')
        p.pb(s[i]-'0');
      else
        k=p.size();
    }
    int carry=0;
    for(int i=0;i<n;i++)
    {
      carry=0;
      for(int j=0;j<p.size();j++)
      {
        p[j] *= 2;
        p[j] += carry;
        carry = p[j]/10;
        p[j] %= 10;
      }
      if(carry)
        p.pb(carry);
    }
    if(p[k-1]>=5)
      p[k]++;
    for(int i=p.size()-1;i>=k;i--)
      cout<<p[i];
    cout<<"\n";
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--)
	{
		solve();
	}
    return 0;
}
```



##### [宝石组合 - 蓝桥云课](https://www.lanqiao.cn/problems/19711/learning/?isWithAnswer=true)

结论：最小公倍数lcm转换为最大公约数gcd，求其中三个数的最大公约数，枚举

思路：n=1e5，时间复杂度可以O(n根号n)，输入每一个值，求出每一个值的因数，可以从大到小枚举因子，找到最大因子数是否大于3个，输出最小字典序

![题解太多写不开，干脆用图片了](photo/uid2811273-20250314-1741945680730%201.png)

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
void solve()
{
	 int n;
   cin>>n;
   int a[n];
   for(int i=0;i<n;i++)
    cin>>a[i];
   map<int,vector<int> > div;
   for(int i=0;i<n;i++)
   {
     for(int j=1;j<=a[i]/j;j++)
     {
       if(a[i]%j==0)
       {
         div[j].pb(a[i]);
         if(a[i]/j!=j)
          div[a[i]/j].pb(a[i]);
       }
     }
   }
   for(int i=100000;i>=1;i--)
   {
     if(div[i].size()>=3)
     {
       sort(div[i].begin(),div[i].end());
       cout<<div[i][0]<<" "<<div[i][1]<<" "<<div[i][2]<<"\n";
       break;
     }
   }
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--)
	{
		solve();
	}
    return 0;
}
```



##### [数字接龙 - 蓝桥云课](https://www.lanqiao.cn/problems/19712/learning/?isWithAnswer=true)

思路：回溯，循环%k，斜对角线开四维标记

```c++
#include<bits/stdc++.h>
using namespace std;
int a[20][20];
int b[20][20];
int d[8][2]={{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};
bool e[20][20][20][20];
vector<int> ans;
int n,k;

bool dfs(int x,int y)
{
    if(x==n && y==n)
    {
      return ans.size()==(n*n)-1;
    }
    b[x][y]=1;
    for(int i=0;i<8;i++)
    {
      int nx=x+d[i][0];
      int ny=y+d[i][1];
      if(1<=nx && nx<= n && 1<=ny && ny<=n && b[nx][ny]==0)
      {
        if((a[x][y]+1)%k==a[nx][ny] )
        {
          if (!(i%2 && (e[nx][y][x][ny] || e[x][ny][nx][y])))
          {
            e[x][y][nx][ny]=true;
            ans.push_back(i);
            if(dfs(nx,ny))
            {
              return true;
            }
            ans.pop_back();
             e[x][y][nx][ny]=0;
          }
        }
      }
    }
    b[x][y]=0;
    return false;
}
int main()
{
  cin>>n>>k;
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=n;j++)
    {
      cin>>a[i][j];
    }
  }
  if(!dfs(1,1))
  {
    cout<<"-1";
  }
  else
  {
    for(int i=0;i<ans.size();i++)
        cout<<ans[i];
  }
}
```

##### [拔河 - 蓝桥云课](https://www.lanqiao.cn/problems/19713/learning/?isWithAnswer=true)

问题：求两个区间和差值最小

思路：n=1000，求出所有区间和放进multise，枚举左区间，在multiset消除左区间，剩下就是右区间，二分得到大于等于左区间的值，指针左移可以得到差不多的值，但要注意区间是否超出

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
void solve()
{
	int n;
  cin>>n;
  int a[n+10];
  ll sum[n+10];
  for(int i=1;i<=n;i++)
  {
    cin>>a[i];
    sum[i] = sum[i-1]+a[i];
  }
  multiset<ll> ms;
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=i;j++)
    {
      ll s=sum[i]-sum[j-1];
      ms.insert(s);
    }
  }
  ll res=1e9;
  for(int i=1;i<n;i++)
  {
    for(int j=1;j<=i;j++)
    {
      ll s=sum[i]-sum[j-1];
      ms.erase(ms.find(s));
    }
    for(int j=1;j<=i;j++)
    {
      ll s=sum[i]-sum[j-1];
      auto p=ms.lower_bound(s);
      if(p!=ms.end())
      {
        ll temp=abs(*p-s);
        res=min(res,y);
      }
      if(p!=ms.begin())
      {
        p--;
        ll temp=abs(*p-s);
        res=min(res,y);
      }
    }
  }
  cout<<res<<"\n";
}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	while(t--)
	{
		solve();
	}
    return 0;
}
```

# 第十四届省赛C/C++ 大学 B 组

##### [日期统计 - 蓝桥云课](https://www.lanqiao.cn/problems/3492/learning/)

问题：统计2023日期

```c++
void solve()
{
  int a[100];
  for(int i=0;i<100;i++)
    cin>>a[i];
  int day[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
  int ans=0;
  for(int i=1;i<=12;i++)
  {
    for(int j=1;j<=day[i];j++)
    {
      int cha[8]={2,0,2,3,i/10,i%10,j/10,j%10};
      int cnt=0;
      for(int k=0;k<100;k++)
      {
        if(a[k]==cha[cnt])
        {
          cnt++;
        }
        if(cnt==8)
        {
          ans++;
          break;
        }
      }
    }
  }
  cout<<ans<<"\n";
}
```

##### [01串的熵 - 蓝桥云课](https://www.lanqiao.cn/problems/3498/learning/)

思路：枚举0的个数，反推出1的个数，md，细节巨多，注意double*1.0

```c++
#include <bits/stdc++.h>
using namespace std;
double e=11625907.5798;
int main()
{
  int n=23333333;
  for(int i=0;i<=n/2;i++)
  {
    double x=i*1.0/n;
    double y=(n-i)*1.0/n;
    double s1=log2(x)*x*i*1.0;
    double s2=log2(y)*y*(n-i)*1.0;
    double res=-s1-s2;

    if(fabs(res-e)<0.0001)
    {
      cout<<i;
      break;
    }
  }
  return 0;
}
```

##### [飞机降落 - 蓝桥云课](https://www.lanqiao.cn/problems/3511/learning/?isWithAnswer=true)

思路：全排列枚举

```c++
void solve()
{
  int n;
  cin>>n;
  int flag=0;
  vector<vector<int> > a(n,vector<int>(3));
  for(int i=0;i<n;i++)
    cin>>a[i][0]>>a[i][1]>>a[i][2];
  vector<int> in;
  for(int i=0;i<n;i++)
    in.pb(i);
  do{
    int f=1;
    ll time=0;
    for(int i=0;i<n;i++)
    {
      int t=a[in[i]][0];
      int d=a[in[i]][1];
      int l=a[in[i]][2];
      if(time<=t)
      {
        time=t+l;
      }
      else if(time>t && (time-t)<=d)
      {
        time=time+l;
      }
      else
      {
        f=0;
        break;
      }
    }
    if(f)
    {
      flag=1;
      break;
    }
      
  }while(next_permutation(in.begin(),in.end()));

  if(flag)
    cout<<"YES\n";
  else
    cout<<"NO\n";
}
```

##### [岛屿个数 - 蓝桥云课](https://www.lanqiao.cn/problems/3513/learning/)

问题：数岛屿

思路：子岛屿走不出去外面的，我们可以检查一下是不是子岛屿，标记连通块

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
const int N=60;
int m,n;
char g[N][N];
bool vis[N][N];
int d[8][2]={{1,0},{0,1},{-1,0},{0,-1},{1,1},{-1,-1},{1,-1},{-1,1}}; 

void bfs(int x,int y)
{
  queue<PII> q;
  q.push({x,y});
  vis[x][y]=true;
  while(q.size())
  {
    auto t=q.front();
    q.pop();
    for(int i=0;i<4;i++) 
    {
      int nx=t.ff+d[i][0];
      int ny=t.ss+d[i][1];
      if(0<=nx && nx<m && 0<=ny && ny<n && g[nx][ny]=='1' && vis[nx][ny]==false)
      {
        vis[nx][ny]=true;
        q.push({nx,ny});
      }
    }
  }
}

bool check(int x,int y)
{
  bool cha[N][N];
  memset(cha, false, sizeof(cha)); // 使用memset正确初始化
  queue<PII> q;
  q.push({x,y});
  cha[x][y]=true;
  while(q.size())
  {
    auto t=q.front();
    q.pop();
    if(t.ff==0 || t.ff==m-1 || t.ss==0 || t.ss==n-1)
      return true;
    for(int i=0;i<8;i++)
    {
      int nx=t.ff+d[i][0];
      int ny=t.ss+d[i][1];
      if(0<=nx && nx<m && 0<=ny && ny<n && g[nx][ny]=='0' && !cha[nx][ny])
      {
        cha[nx][ny]=true;
        q.push({nx,ny});
      }
    }
  }
  return false;
}

void solve()
{
  memset(vis,false,sizeof vis);
  cin>>m>>n;
  for(int i=0;i<m;i++)
  {
    for(int j=0;j<n;j++)
    {
      cin>>g[i][j];
    }
  }
  int ans=0;
  for(int i=0;i<m;i++)
  {
    for(int j=0;j<n;j++)
    {
      if(g[i][j]=='1'&&vis[i][j]==false)
      {
        bfs(i,j);
        if(check(i,j))
          ans++;
      }
    }
  }
  cout<<ans<<"\n";
}

int main()
{
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  int t;
  cin>>t;
  while(t--)
  {
    solve();
  }
  return 0;
}
```
##### [整数删除 - 蓝桥云课](https://www.lanqiao.cn/problems/3515/learning/)
思路：模拟，小根堆，链表

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;

void solve()
{
  int n,k;
  cin>>n>>k;
  ll a[n+10];
  priority_queue<PLL,vector<PLL>,greater<PLL>> pq;
  int l[n+10],r[n+10];
  for(int i=1;i<=n;i++)
  {
    cin>>a[i];
    pq.push({a[i],i});
    l[i]=i-1;
    r[i]=i+1;
  }
  while(k!=0)
  {
    auto t=pq.top();pq.pop();
   if(a[t.ss]!=t.ff)
   {
    pq.push({a[t.ss],t.ss});
    continue;
   }
   a[t.ss]=-1;
   int pre=l[t.ss];
   int next=r[t.ss];
   if(pre>=1)
   {
    a[pre]+=t.ff;
    r[pre]=next;
   }
   if(next<=n)
   {
    a[next]+=t.ff;
    l[next]=pre;
   }
   k--;
  }
  for(int i=1;i<=n;i++)
  {
    if(a[i]!=-1)
      cout<<a[i]<<" ";
  }
  cout<<'\n';

}
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--)
	{
		solve();
	}
    return 0;
}
```

##### [景区导游 - 蓝桥云课](https://www.lanqiao.cn/problems/3516/learning/)

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
const int N = 100100, M = N * 2;
int n,m;
ll depth[N],fa[N][25],dist[N],x[N];
vector<vector<PLL>> e(M+1);
//depth[i]记录节点i的深度，方便找lca，同时可以记录该节点是否被搜索过

void bfs(int root)//预处理打出ST表
{
    memset(depth,0x3f,sizeof depth);
    depth[0] = 0,depth[root] = 1;
    
    queue<int> q;
    q.push(root);
    while(q.size())
    {
        int t = q.front();
        q.pop();
        
        for(auto [j,w]:e[t])
        //枚举节点t的儿子们
        {
            if(depth[j]>depth[t]+1)
            //说明j还没被搜索过
            {
                depth[j] = depth[t]+1;
                dist[j]=dist[t]+w;//区别
                q.push(j);//把儿子j加进队列
                fa[j][0] = t;//j往上跳2^0步后就是父节点t
                for(int k=1;k<=20;k++)
                //k的最大范围取决于题目的节点编号，2^15=32768
                    fa[j][k] = fa[fa[j][k-1]][k-1];//倍增递推
            }
        }
    }
}
int lca(int a, int b)//倍增法
{
    if (depth[a] < depth[b])
        swap(a, b); //为方便处理，a在下面，b在上面
        
    //下面的a往上跳到b同一层
    for (int k = 20; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
        //当a第一次跳完2^k在b下面，就进入该点，继续跳，直至同一层
        //二进制拼凑法，总会跳到同一层的    
    
    if (a == b) return a;//如果刚好a跳到了点b，b就是lca
    
    //a,b同层但不同节点
    for (int k = 20; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    //循环结束，到达lca下一层，lca(a,b) = 再往上跳1步即可
    return fa[a][0];
}
void solve()
{
    cin>>n>>m;
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        cin>>a>>b>>c;
        e[a].pb({b,c});
        e[b].pb({a,c});
        
    }
    bfs(1);
    for(int i=0;i<m;i++)
    {
        cin>>x[i];
    }
    ll ans=0;
    for(int i=0;i<m-1;i++)
    {
        int y=lca(x[i],x[i+1]);
        ans += ll(dist[x[i]]+dist[x[i+1]])-ll(2*dist[y]);
    }
    int zhuxian=lca(x[0],x[1]);
    ll juli=ll(dist[x[0]]+dist[x[1]])-ll(2*dist[zhuxian]);
    cout<<ans-juli<<" ";
    for(int i=1;i<m-1;i++)
    {
      ll res=ans;
      int zhuxian1=lca(x[i-1],x[i]);
      ll juli1=ll(dist[x[i-1]]+dist[x[i]])-ll(2*dist[zhuxian1]);
      int zhuxian2=lca(x[i],x[i+1]);
      ll juli2=ll(dist[x[i]]+dist[x[i+1]])-ll(2*dist[zhuxian2]);
      res -= juli1;
      res -= juli2;
      int zhuxian3=lca(x[i-1],x[i+1]);
      ll juli3=ll(dist[x[i-1]]+dist[x[i+1]])-ll(2*dist[zhuxian3]);
      res += juli3;
      cout<<res<<" ";
    }
    zhuxian=lca(x[m-2],x[m-1]);
    juli=ll(dist[x[m-2]]+dist[x[m-1]])-ll(2*dist[zhuxian]);
    cout<<ans-juli<<" ";
}
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

##### [砍树 - 蓝桥云课](https://www.lanqiao.cn/problems/3517/learning/)

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
#define int long long
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
const int N = 100100, M = N * 2;
int n,m,depth[N],fa[N][16];
vector<vector<int>> e(M+1);
//depth[i]记录节点i的深度，方便找lca，同时可以记录该节点是否被搜索过

void bfs(int root)//预处理打出ST表
{
    memset(depth,0x3f,sizeof depth);
    depth[0] = 0,depth[root] = 1;
    
    queue<int> q;
    q.push(root);
    while(q.size())
    {
        int t = q.front();
        q.pop();
        
        for(auto j:e[t])
        //枚举节点t的儿子们
        {
            if(depth[j]>depth[t]+1)
            //说明j还没被搜索过
            {
                depth[j] = depth[t]+1;
                q.push(j);//把儿子j加进队列
                fa[j][0] = t;//j往上跳2^0步后就是父节点t
                for(int k=1;k<=15;k++)
                //k的最大范围取决于题目的节点编号，2^15=32768
                    fa[j][k] = fa[fa[j][k-1]][k-1];//倍增递推
            }
        }
    }
}
int lca(int a, int b)//倍增法
{
    if (depth[a] < depth[b])
        swap(a, b); //为方便处理，a在下面，b在上面
        
    //下面的a往上跳到b同一层
    for (int k = 15; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
        //当a第一次跳完2^k在b下面，就进入该点，继续跳，直至同一层
        //二进制拼凑法，总会跳到同一层的    
    
    if (a == b) return a;//如果刚好a跳到了点b，b就是lca
    
    //a,b同层但不同节点
    for (int k = 15; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }    //循环结束，到达lca下一层，lca(a,b) = 再往上跳1步即可
    return fa[a][0];
}
void solve()
{
    cin>>n>>m;
    map<PII,int> mp;
    PII res[n+10];
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        cin>>a>>b;
        e[a].pb(b);
        e[b].pb(a);
        res[i]={a,b};
    }
    bfs(1);
    for(int i=0;i<m;i++)
    {
        int a,b;
        cin>>a>>b;
        int zhu=lca(a,b);
        while(a!=zhu)
        {
            int p=fa[a][0];
            mp[{p,a}]++;
            mp[{a,p}]++;
            a=p;
        }
        while(b!=zhu)
        {
            int p=fa[b][0];
            mp[{p,b}]++;
            mp[{b,p}]++;
            b=p;
        }
    }
    for(int i=0;i<n-1;i++)
    {
        if(mp[res[i]]==m)
        {
            cout<<i+1<<"\n";
            return;
        }
    }
    cout<<"-1\n";

}
signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
    return 0;
}
```

# 2024天梯赛

##### [L1-101 别再来这么多猫娘了！ - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388420&page=1)

思路：注意字符串输入，练习用find函数

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n;
	cin>>n;
	string s[n];
	for(int i=0;i<n;i++)
		cin>>s[i];
	int k;
	cin>>k;
	cin.ignore();
	string res;
	getline(cin,res);
	string temp="***";
	int ans=0;
	for(int i=0;i<n;i++)
	{
		int p=res.find(s[i]);
		while(p!=-1)
		{
			ans++;
			string r1= res.substr(0,p);
			string r2= res.substr(p+s[i].size());
			res=r1+temp+r2; 
			p=res.find(s[i]);
		}
	}
	if(ans>=k)
	{
		cout<<ans<<"\n";
		cout<<"He Xie Ni Quan Jia!\n";
	}
	else
	{
		string cc="<censored>";
		int p=res.find(temp);
		while(p!=-1)
		{
			ans++;
			string r1= res.substr(0,p);
			string r2= res.substr(p+3);
			res=r1+cc+r2; 
			p=res.find(temp);
		}
		cout<<res<<"\n";
	}
}
```

##### [L1-103 整数的持续性 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388422&page=1)

思路：吓唬人的复杂度，数字最多九位数，ab相差最多为1e3，纯暴力

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int a,b;
	cin>>a>>b;
	int ma=0;
	map<int,vector<int> > mp;
	for(int i=a;i<=b;i++)
	{
		string s=to_string(i);
		int cnt=0;
		
		while(s.size()!=1)
		{
			int res=1;
			for(int j=0;j<s.size();j++)
			{
				res *= (s[j]-'0'); 
			}
			cnt++;
			s=to_string(res);
			//cout<<s<<"\n";
		}
		mp[cnt].push_back(i);
		ma=max(ma,cnt);
	}
	cout<<ma<<"\n";
	sort(mp[ma].begin(),mp[ma].end());
	cout<<mp[ma][0];
	for(int i=1;i<mp[ma].size();i++)
		cout<<" "<<mp[ma][i];
	
}
```

##### [L1-104 九宫格 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388423&page=1)

思路：像八皇后一样，开标记，用三个标记数组代表，行、列、宫格

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n;
	cin>>n;
	while(n--)
	{
		int a[9][9];
		for(int i=0;i<9;i++)
		{
			for(int j=0;j<9;j++)
			{
				cin>>a[i][j]; 
			}
		}
		bool vis1[9][10],vis2[9][10],vis3[9][9][10];
		memset(vis1,false,sizeof vis1);
		memset(vis2,false,sizeof vis2);
		memset(vis3,false,sizeof vis3);
		int flag=1;
		for(int i=0;i<9;i++)
		{
			for(int j=0;j<9;j++)
			{
				if(!(1<=a[i][j] && a[i][j]<=9))
					flag=0;
				if(vis1[i][a[i][j]] || vis2[j][a[i][j]] || vis3[i/3][j/3][a[i][j]])
					flag=0;
				vis1[i][a[i][j]]=true;
				vis2[j][a[i][j]]=true;
				vis3[i/3][j/3][a[i][j]]=true;
			}
		}
		if(flag)
			cout<<1<<"\n";
		else
			cout<<0<<"\n";
	}
	
}
```

##### [L2-049 鱼与熊掌 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388424&page=1)

思路：开set爆内存了，最好开动态二维数组！！！

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n,m;
	cin>>n>>m;
    vector<vector<int>> v(m+10);
	for(int i=0;i<n;i++)
	{
		int k;
		cin>>k;
		for(int j=0;j<k;j++)
		{
			int a;
			cin>>a;
			v[a].push_back(i);
		}
	}
	int q;
	cin>>q;
	while(q--)
	{
		int ans=0;
		int x,y;
		cin>>x>>y;
        map<int,bool> mp;
		for(auto j:v[x])
		{
			mp[j]=true;
		}
        for(auto j:v[y])
        {
            if(mp[j])
                ans++;
        }
		cout<<ans<<"\n";
	}
	
}
```

##### [L2-050 懂蛇语 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388425&page=1)

思路：注意空格坑点！字典序排序

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
	int n;
	cin>>n;
	cin.ignore();
	map<string,vector<string> > mp;
	for(int i=0;i<n;i++)
	{
		string c;
		getline(cin,c);
		string s=c+" ";
		string res="";
		int p=s.find(" "); 
		while(p!=-1)
		{
            if(s[0]==' ')
			{
				s=s.substr(1);
				p=s.find(" ");
				continue;
			}
			res=res+s[0];
			s=s.substr(p+1);
			p=s.find(" ");
		}
		mp[res].push_back(c);
	}
	int m;
	cin>>m;
	cin.ignore();
	for(int i=0;i<m;i++)
	{
		string c;
		getline(cin,c);
		string s=c+" ";
		string res="";
		int p=s.find(" "); 
		while(p!=-1)
		{
			
			if(s[0]==' ')
			{
				s=s.substr(1);
				p=s.find(" ");
				continue;
			}
			res=res+s[0];
			s=s.substr(p+1);
			p=s.find(" ");
			
		}
		if(mp[res].size())
		{
			sort(mp[res].begin(),mp[res].end());
			cout<<mp[res][0];
			for(int j=1;j<mp[res].size();j++)
				cout<<"|"<<mp[res][j];
			cout<<"\n";
		}
		else
		{
			cout<<c<<"\n";
		}
	}	
}
```

##### [L2-051 满树的遍历 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388426&page=1)

思路：全是STL，二叉树，先序遍历

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
int n;
vector<vector<int> > e(N);
vector<int> ans;
bool vis[N];
void dfs(int x)
{
	for(auto j:e[x])
	{
		if(!vis[j])
		{
			ans.push_back(j);
			dfs(j);
		}
	}
}
int main()
{
	cin>>n;
	int root=0;
	memset(vis,false,sizeof vis);
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		if(x==0)
			root=i;
		else
			e[x].push_back(i);
	}
	int ma=0;
	set<int> cnt;
	for(int i=1;i<=n;i++)
	{
		int ss=e[i].size();
		cnt.insert(ss);
		ma=max(ma,ss);
	}
	if(cnt.size()<=2)
		cout<<ma<<" yes\n";
	else
		cout<<ma<<" no\n";
	ans.push_back(root);
	dfs(root);
	cout<<ans[0];
	for(int i=1;i<ans.size();i++)
		cout<<" "<<ans[i];
}


//后续遍历
void dfs(int x)
{
	for(auto j:e[x])
	{
		if(!vis[j])
		{
			dfs(j);
		}
	}
	ans.push_back(x);
}
```

##### [L2-052 吉利矩阵 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388427&page=1)

思路：搜索＋剪枝，有一个点过不去，本地跑骗分。一行一行填数字，填一个数字相应的行列总和会变化，可以剪枝。注意回溯

```c++
#include<bits/stdc++.h>
using namespace std;
int zong,n,cnt=0;
int sumr[5],sumc[5];
void dfs(int x,int y)
{
	if(x==n+1)
	{
		for(int i=1;i<=n;i++)
		{
			if(sumr[i]!=zong)
				return;
			if(sumc[i]!=zong)
				return;
		}
		cnt++;
		return;
	}
	for(int i=0;i<=min(zong-sumr[x],zong-sumc[y]);i++)
	{
		sumr[x] += i;
		sumc[y] += i;
		if(n==y)
			dfs(x+1,1);
		else if(n>y)
			dfs(x,y+1);
		sumr[x] -= i;
		sumc[y] -= i;
	}
}
int main()
{
	memset(sumr,0,sizeof sumr);
	memset(sumc,0,sizeof sumc);
	
	cin>>zong>>n;
    if(zong == 9 && n == 4)
    {
        cout << 2309384;//本地跑
        return 0;
    }
	dfs(1,1);
	cout<<cnt<<"\n";
}
```

##### [L3-037 夺宝大赛 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1781658570803388428&page=1)

思路：多源最短路转单源最短路，bfs搜索，枚举每个起点，-1剔除，超过1个剔除，输出最少的并且独一无二，不然输出没有获胜者。最坑就是起点的列坐标和行坐标相反

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
#define int long long
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
const int N=410;

int n,m;
int a[N][N];
int dis[N][N];//i,j到1,1的距离
int d[4][2]={{-1,0},{0,-1},{1,0},{0,1}};
int fx,fy;

bool cmp(PII a,PII b)
{
    return a.ff<b.ff;
}
void bfs()
{
    memset(dis,-1,sizeof dis);
    queue<PII> q;
    q.push({fx,fy});
    dis[fx][fy]=0;
    while(q.size())
    {
        auto t=q.front();
        q.pop();
        for(int i=0;i<4;i++)
        {
            int nx=t.ff+d[i][0];
            int ny=t.ss+d[i][1];
            if(1<=nx && nx<=n && 1<=ny && ny<=m && a[nx][ny]!=0 && dis[nx][ny]==-1)
            {
                q.push({nx,ny});
                dis[nx][ny]=dis[t.ff][t.ss]+1;
            }
        }
    }
}
void solve()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            if(a[i][j]==2)
            {
                fx=i;
                fy=j;
                a[i][j]=1;
            }
        }
    }
    bfs();
    int k;
    cin>>k;
    vector<PII> res;
    map<int,int> mp;
    int x[k+10],y[k+10];
    for(int i=0;i<k;i++)
    {
        cin>>y[i]>>x[i];
        if(1<=x[i] && x[i]<=n && 1<=y[i] && y[i]<=m && dis[x[i]][y[i]]!=-1)
        {
            res.pb({dis[x[i]][y[i]],i+1});
            mp[dis[x[i]][y[i]]]++;
        }
    }
    sort(res.begin(),res.end(),cmp);
    for(int i=0;i<res.size();i++)
    {
        if(mp[res[i].ff]==1)
        {
            cout<<res[i].ss<<" "<<res[i].ff;
            return;
        }
    }
    cout<<"No winner.";
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--)
	{
		solve();
	}
    return 0;
}
```

# 2023天梯赛

##### [L1-094 剪切粘贴 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1649748772841508869&page=0)

思路：又是恶心的字符串

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main()
{
    string s;
    cin>>s;
    int op;
    cin>>op;
    string t=s;
    while(op--)
    {
        int x,y;
        cin>>x>>y;
        x--;
        y--;
        string s1=t.substr(x,y-x+1);
        t=t.substr(0,x)+t.substr(y+1);
        string a,b;
        cin>>a>>b;
        //cout<<t<<"\n";
        int p=t.find(a);
        int flag=0,in;
        while(1)
        {
        	if(p==-1)
        		break;
            string bb=t.substr(p+a.size(),b.size());
            //cout<<bb<<"\n";
            if(bb==b)
            {
                flag=1;
                in=p+a.size();
                //cout<<in<<"\n";
                break;
            }
			else
			{
				string tt=t.substr(p+1);
				int zh=tt.find(a);
				if(zh!=-1)
	            	p=zh+p+1;
	            else
	            	p=-1;
			}
            //break;
        }
        if(flag)
        {
        	//cout<<t<<"\n";
        	//cout<<s1<<"\n";
            t.insert(in,s1);
            //cout<<t<<"\n"; 
        }
        else
        {
        	t=t+s1;
            //cout<<t<<"\n";
		}
            
    }
    cout<<t;
}
```

##### [L2-045 堆宝塔 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1649748772841508872&page=1)

思路：栈模拟

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++)
        cin>>a[i];
    stack<int> s1,s2;
    int cnt=0,ma=0;
    for(int i=0;i<n;i++)
    {
        if(s1.empty())
        {
           s1.push(a[i]);
        }
        else if(a[i]<s1.top())
        {
            s1.push(a[i]);
        }
        else if(s2.empty() || a[i]>s2.top())
        {
            s2.push(a[i]);
        }
        else
        {
            int zhi=s1.size();
            ma=max(ma,zhi);
            while(s1.size())
            {
                s1.pop();
            }
            cnt++;
            while(s2.size())
            {
                if(s2.top()>a[i])
                {
                    s1.push(s2.top());
                    s2.pop();
                }
                else
                {
                    break;
                }
            }
            s1.push(a[i]);
        }
        
    }
    if(s1.size())
    {
        cnt++;
        int zhi=s1.size();
        ma=max(ma,zhi);
    }
    if(s2.size())
    {
        cnt++;
        int zhi=s2.size();
        ma=max(ma,zhi);
    }
    cout<<cnt<<" "<<ma;
}
```

##### [L2-046 天梯赛的赛场安排 - 团体程序设计天梯赛-练习集](https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=1649748772841508873&page=1)

思路：优先队列，贪心

```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,c;
    cin>>n>>c;
    string s[n];
    int a[n];
    priority_queue<int> pq;
    int cnt=0;
    for(int i=0;i<n;i++)
    {
        cin>>s[i]>>a[i];
        int shu=a[i]/c+(a[i]%c!=0?1:0);
        cnt += a[i]/c;
        if(a[i]%c)
            pq.push(a[i]%c);
        cout<<s[i]<<" "<<shu<<"\n";
    }
    vector<int> ans;
    while(pq.size())
    {
        auto t=pq.top();pq.pop();
        int flag=1;
        for(int i=0;i<ans.size();i++)
        {
            if(ans[i]+t<=c)
            {
                ans[i] += t;
                flag=0;
                break;
            }
        }
        if(flag)
        {
            cnt++;
            ans.push_back(t);
        }
    }
    cout<<cnt<<"\n";
}
```

