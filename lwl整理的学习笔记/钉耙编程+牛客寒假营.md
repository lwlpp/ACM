## [2025“钉耙编程”中国大学生算法设计春季联赛（4）](https://acm.hdu.edu.cn/contest/problems?cid=1153)

##### [1005 持家](https://acm.hdu.edu.cn/contest/problem?cid=1153&pid=1005)

问题：价格为P，n张优惠券，可以使用k张。优惠券有两种：t=0，代表打Pi折，t=1，代表减Pi元。

思路：贪心，可以发现打折永远比减元更贪心，可以减到负元，代表0元。开两个数组，代表打折和减元，一个求前缀积，一个求前缀和，枚举打折的次数，可以反推出减元的次数，知1定1。

```c++
void solve()
{
	double p;
	int n,k;
	cin>>p>>n>>k;
	vector<int> a,b;
	a.pb(0);
	b.pb(0);
	for(int i=0;i<n;i++)
	{
		int t,m;
		cin>>t>>m;
		if(t==0)
			a.pb(m);
		else 
			b.pb(m);
	}
	sort(a.begin()+1,a.end());
	sort(b.begin()+1,b.end(),greater<int>() );
	double mul[n+10];
	mul[0]=1.0;
	for(int i=1;i<a.size();i++)
		mul[i] = mul[i-1] * (a[i]/10.0);
	double sum[n+10];
	sum[0]=0.0;
	for(int i=1;i<b.size();i++)
		sum[i] = sum[i-1] + b[i];
	double ans=p;
	for(int i=0;i<=k;i++)
	{
		int j=k-i;
		if(i<a.size() && j<b.size())
		{
			ans = min (ans,p*mul[i]-sum[j]);
		}
	}
	ans=max(ans,0.0);
	cout << fixed << setprecision(2) << ans<<"\n";
}
```



# 寒假营1

##### [H-井然有序之窗_2025牛客寒假算法基础集训营1](https://ac.nowcoder.com/acm/contest/95323/H)

思路：枚举每个数，在哪些区间可以选，我们挑那种最短的区间。考虑时间，我们可以按左端点排序区间，找到符合区间的压入小根堆

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
#define int long long
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
 
void solve()
{
	int n;
	cin>>n;
	vector<vector<int>> p;
	for(int i=0;i<n;i++)
	{
		int l,r;
		cin>>l>>r;
		p.pb({l,r,i});
	}
	sort(p.begin(),p.end());
	priority_queue<PII,vector<PII>,greater<PII> > pq;
	bool ok=true;
	vector<int> ans(n,0);
	int num=0;
	for(int i=1;i<=n;i++)
	{
		//cout<<i<<"\n";
		while(num<n && p[num][0]<=i)
		{
			pq.push({p[num][1],p[num][2]});
			num++;
		}
		if(pq.empty() || pq.top().ff<i)
		{
			ok=false;
			break;
		}
		ans[pq.top().ss]=i;
		pq.pop();
	}
	if(ok)
	{
		for(auto j:ans)
			cout<<j<<" ";
		cout<<"\n";
	}
	else {
		cout<<"-1\n";
	}
}
 
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--)
	{
		solve();
	}
    return 0;
}
```

##### [J-硝基甲苯之袭_2025牛客寒假算法基础集训营1](https://ac.nowcoder.com/acm/contest/95323/J)

思路：x^y=gcd(x,y)，对于一个数而言，它和任意一个数的gcd一定是它的某个因子。知道因子，便可以知道y

```c++
#include<bits/stdc++.h>
using namespace std;
#define ff first 
#define ss second
#define pb push_back
#define int long long
using ll = long long; 
using PII = pair<int,int>;
using PLL = pair<ll,ll>;
 
void solve()
{
	int n;
	cin>>n;
	int a[n];
	map<int,int> mp;
	set<int> s;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
		s.insert(a[i]);
		mp[a[i]]++;
	}
	int ans=0;
	for(auto x:s)
	{
		for(int j=1;j<=(x/j);j++)
		{
			if(x%j==0)
			{
				int res=j;
                int y=x^res;
                
				if((x^y)==__gcd(x,y) )
                {
                    ans += mp[x] * mp[y];
                    //cout<<x<<" "<<y<<"\n";
                }
					
                res=x/j;
                if(res==j)
                {
                    continue;
                }
                y=x^res;
				if( (x^y)==__gcd(x,y) )
                {
                    ans += mp[x] * mp[y];
                    //cout<<"ww"<<x<<" "<<y<<"\n";
                }
					
			}
		}
	}
	cout<<ans/2<<"\n";
}
 
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int t=1;
	//cin>>t;
	while(t--)
	{
		solve();
	}
    return 0;
}
```

